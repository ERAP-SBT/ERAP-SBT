%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% TUM-Vorlage: Präsentation
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%
% Rechteinhaber:
%     Technische Universität München
%     https://www.tum.de
%
% Gestaltung:
%     ediundsepp Gestaltungsgesellschaft, München
%     http://www.ediundsepp.de
%
% Technische Umsetzung:
%     eWorks GmbH, Frankfurt am Main
%     http://www.eworks.de
%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% Zur Wahl des Seitenverhältnisses bitte einen der beiden folgenden Befehle
% auskommentieren und den ausführen lassen:
\input{praeambel_16_9.tex} % Seitenverhältnis 16:9
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\input{settings.tex}                    % !!! DATEI ANPASSEN !!!
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\newcommand{\Datum}{\today}

\renewcommand{\PraesentationFusszeileZusatz}{Rechnerarchitektur-Großpraktikum 2021 | Statische Binärübersetzung von RISC-V in x86-64}

\title{Statische Binärübersetzung von RISC-V in x86-64}
\author{Lukas Döllerer, Jonathan Hettwer, Johannes Maier, Tobias Schwarz, Felix Solcher}
\institute[]{Rechnerarchitektur-Großpraktikum 2021}
\date[\Datum]{Garching, 16. Juli 2021}
\subject{Statische Binärübersetzung von RISC-V in x86-64}


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\input{entry.tex} % !!! NICHT ENTFERNEN !!!
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%


%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
% FOLIENSTIL: Standard
\PraesentationMasterStandard

\PraesentationTitelseite % Fügt die Startseite ein


% draws an arrow from (#2,#3) to (#2+#4,#3) with height of #5 (arrow in x direction)
% color (and other arguments, like visible on), startX, startY, length (X dir), height (Y dir)
\newcommand{\TikZArrowX}[5]{
    \filldraw[#1] (#2,#3) -- (#2,#3+#5*2/3) -- (#2+#4/2,#3+#5*2/3) -- (#2+#4/2,#3+#5) -- (#2+#4,#3) -- (#2+#4/2,#3-#5) -- (#2+#4/2,#3-#5*2/3) -- (#2,#3-#5*2/3) -- (#2,#3);
    \draw[#1, black] (#2,#3) -- (#2,#3+#5*2/3) -- (#2+#4/2,#3+#5*2/3) -- (#2+#4/2,#3+#5) -- (#2+#4,#3) -- (#2+#4/2,#3-#5) -- (#2+#4/2,#3-#5*2/3) -- (#2,#3-#5*2/3) -- (#2,#3);
}

% draws an arrow from #2,#3) to (#2,#3+#5) with height of #4 (arrow in y direction)
% color (and other arguments, like visible on), startX, startY, length (X dir), height (Y dir), color
\newcommand{\TikZArrowY}[5]{
    \filldraw[#1] (#2,#3) -- (#2+#4*2/3,#3) -- (#2+#4*2/3,#3+#5/2) -- (#2+#4,#3+#5/2) -- (#2,#3+#5) -- (#2-#4,#3+#5/2) -- (#2-#4*2/3,#3+#5/2) -- (#2-#4*2/3,#3) -- (#2,#3);
    \draw[#1, black] (#2,#3) -- (#2+#4*2/3,#3) -- (#2+#4*2/3,#3+#5/2) -- (#2+#4,#3+#5/2) -- (#2,#3+#5) -- (#2-#4,#3+#5/2) -- (#2-#4*2/3,#3+#5/2) -- (#2-#4*2/3,#3) -- (#2,#3);
}

% draws one entry of the color legend for the program scheme
% color, text, posX, posY (left, top coordinate)
\newcommand{\colorLegendEntry}[4]{
    \filldraw[#1] (#3,#4) rectangle (#3+1,#4+1);
    \draw[black] (#3,#4) rectangle (#3+1,#4+1);
    \node at (#3+0.5,#4+0.4) (color_legend_entry_point) {};
    \node[right=2mm of color_legend_entry_point] (color_legend_entry_text) {#2};
}

% draws a color legend for the program scheme
% posX, posY (left, top coordinate)
\newcommand{\colorLegend}[2] {
    \colorLegendEntry{TUMOrange}{Static Translator Parts}{#1}{#2}
    \colorLegendEntry{TUMBlauDunkel}{Immediate Representation (IR)}{#1}{#2-1.5}
    \colorLegendEntry{purple}{Maschine Code / ELF File}{#1}{#2-3}
}

% draws the schematic presentation of the program
% scale, fontSize
\newcommand{\ProgramSchemeVersionOne}[2]{
    \begin{center}
        \begin{tikzpicture}[very thick, scale=#1]
            % draw color legend
            \colorLegend{-2}{-6}

            % riscv elf file rectangle
            % background
            \filldraw[purple, visible on=<2->] (-2,-2) rectangle (2,2);
            % black border
            \draw[black, visible on=<2->] (-2,-2) rectangle (2,2);
            % label
            \node[align=center, visible on=<2->] at (0,0) (riscv_text) {\fontsize{#2}{#2} \selectfont RISC-V};

            % lifter arrow
            \TikZArrowX{TUMOrange, visible on=<3->}{2}{0}{6}{1.5}
            % arrow label
            \node[align=center, visible on=<3->] at (4.5,0) (lifter_text) {\fontsize{#2}{#2} \selectfont Lifter};

            % ir (unoptimized) rectangle
            % background
            \filldraw[TUMBlauDunkel, visible on=<3->] (8,-2) rectangle (12,2);
            % black border
            \draw[black, visible on=<3->] (8,-2) rectangle (12,2);
            % label
            \node[align=center, visible on=<3->] at (10,0) (ir_text_1) {\fontsize{#2}{#2} \selectfont IR};

            % optimizer arrow
            \TikZArrowX{TUMOrange, visible on=<4->}{12}{0}{6}{1.5}
            % arrow label
            \node[align=center, visible on=<4->] at (14.5,0) (optimizer_text) {\fontsize{#2}{#2} \selectfont Optimizer};

            % ir (optimized) rectangle
            % background
            \filldraw[TUMBlauDunkel, visible on=<4->] (18,-2) rectangle (22,2);
            % black border
            \draw[black, visible on=<4->] (18,-2) rectangle (22, 2);
            % label
            \node[align=center, visible on=<4->] at (20,0) (ir_text_2) {\fontsize{#2}{#2} \selectfont IR};

            % compiler arrow
            \TikZArrowX{TUMOrange, visible on=<5->}{22}{0}{6}{1.5}
            % arrow label
            \node[align=center, visible on=<5->] at (24.5,0) (compiler_text) {\fontsize{#2}{#2} \selectfont Compiler};

            % x86_64 rectangle
            %background
            \filldraw[purple, visible on=<5->] (28,-2) rectangle (32,2);
            % black border
            \draw[black, visible on=<5->] (28,-2) rectangle (32,2);
            % label
            \node[align=center, visible on=<5->] at (30,0) (x86_64_text) {\fontsize{#2}{#2} \selectfont x86\_64};
        \end{tikzpicture}
    \end{center}
}



%%%%%%%%%%%%%%%%%%%%%%%
%% Programmübersicht %%
%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}
    \frametitle{Programmübersicht}
    \note[item]{RISC, feste 32-Bit Befehlslänge}
    \note[item]{wenige, einfache Befehle -> geringe Codedichte, aber leicht zu übersetzten}
    \note[item]{Register-Register-Maschine}
    \note[item]{Compiler compiliert zu Assemlby Code und dieser wird zu einer ausführbaren Datei}

    %alignment to have some space between headline an the schematic
    ~\\
    ~\\
    \ProgramSchemeVersionOne{0.6}{18}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%
%% IR Aufbau Folie %%
%%%%%%%%%%%%%%%%%%%%%

\begin{frame}
    \frametitle{Intermediate Representation}{Aufbau}
    \note[item]{Selbst definierte Zwischenrepräsentation}
    \note[item]{Hauptbestandteil: Basic Blocks}
    \note[item]{-> Sequentielle Folge von Instruktionen, die durch Kontrollflussoperation beendet werden}
    \note[item]{Basic Block enthält Variablen in sogenannter SSA-Form und die dazu gehörenden Operationen}
    \note[item]{Static single assignment -> Jeder var wird nur einmal Wert zugewiesen}
    \note[item]{-> Vereinfacht Optimierungen}
    \note[item]{Eingaben kommen als "Statics" -> Abstrakte Darstellung von RISCV-Registern}
    \note[item]{Kontrollflussoperationen verbinden die Basic Blocks}
    \note[item]{SSA bedeutet: Variablen frei verschiebbar, deshalb Memory Tokens für Einhaltung der Reihenfolge}
    \pause{}
    \begin{itemize}
        \item Die IR besteht aus mehreren "`\textbf{Basic Blocks}"'
              \pause{}
        \item Basic Block: Eine Folge von sequentiellen Instruktionen, beendet durch eine Kontrollflussoperation
              \pause{}
        \item Ein Basic Block enthält Variablen in SSA-Form und dazugehörige Operationen
              \pause{}
        \item \textbf{Static single assignment (SSA):} Jeder Variable wird genau einmal ein Wert zugewiesen
              \pause{}
        \item Ein Basic Block erhält Eingaben in Form von Statics
              \pause{}
        \item Die Basic Blocks sind durch die Kontrollflussoperationen miteinander verbunden
              \pause{}
        \item Zur Nachvervolgung von Lese- und Schreiboperationen gibt es Memory Tokens $\rightarrow$ Optimierungen
    \end{itemize}
\end{frame}

\begin{frame}
    \frametitle{Intermediate Representation}{Operationen}
    \pause{}

    ~\\
    ~\\

    \begin{columns}[c]
        \column{0.4\textwidth}
        Instruktionen:
        \begin{itemize}
            \item Speicher: \texttt{store}, \texttt{load}
            \item Arithmetisch: \texttt{add}, \texttt{sub}, \texttt{mul}, ...
            \item Logisch: \texttt{and}, \texttt{or}, \texttt{shl}, ...
            \item Sonstige: Typkonvertierung, ...
        \end{itemize}

        \pause{}
        \column{0.4\textwidth}
        Kontrollflussoperationen:
        \begin{itemize}
            \item Sprünge: \texttt{jump}, \texttt{ijump}, \texttt{cjump}
            \item \texttt{unreachable}
            \item \texttt{syscall}
        \end{itemize}
    \end{columns}
\end{frame}

%%%%%%%%%%%%%%
%% IR Folie %%
%%%%%%%%%%%%%%

\begin{frame}[fragile]
    \frametitle{Intermediate Representation}{Beispiel}
    \pause{}
    ~\\
    ~\\
    ~\\
    \begin{columns}[c]
        \column{0.275 \textwidth}
        \begin{lstlisting}[language=rv64]
        [...]
        addi a0, x0, 100
        j somewhere_else
        [...]
        \end{lstlisting}

        \pause{}
        \column{0.125 \textwidth}
        \begin{tikzpicture}[scale=0.72]
            \TikZArrowX{TUMOrange}{0}{0}{4}{1}
        \end{tikzpicture}

        \pause{}

        \column{0.6 \textwidth}
        \begin{lstlisting}[language=SbtIr]
block b1(/* inputs */) <= [/* predecessors */] {
    i64 v0 <- @1
    [...] // more statics
    imm v32 <- immediate 0
    imm v33 <- immediate 100
    i64 v34 <- add imm v32, imm v33
} => [(jump, [b2, i64 v34])]
    \end{lstlisting}
    \end{columns}

\end{frame}
\clearpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% ELF File Parser Folie %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[fragile]
    \frametitle{Lifter}{ELF Binärdatei laden und Instruktionsbytes decodieren}
    \begin{columns}[c]
        \column{0.5 \textwidth}
        \begin{enumerate}
            \visible<2-> {
            \note[item]{ELF Prüfung: Prüfbits, System-V ABI, 64-Bit, Little Endian, RISC-V Machine}
            \item ELF File prüfen.
                  }
                  \visible<3-> {
                  \note[item]{Symbole weren bei gestrippten ELF-Binaries nicht eingelesen}
            \item Program Header, Sections und Symbole auslesen.
                  }
                  \visible<4-> {
                  \note[item]{32-Byte bzw. 16-Byte Compressed mit frvdec decodieren}
            \item Section Bytes $\rightarrow$ Instruktionen durch \textbf{frvdec} decodieren.
                  }
        \end{enumerate}
        \column{0.50 \textwidth}
        \begin{lstlisting}[basicstyle=\footnotesize, breaklines=true, escapeinside={@@}]
ELF Header:
    Magic:   7f 45 4c 46 02 01 01 00 00 00 00 00 00 00 00 00
    Class:                             @\textcolor{TUMBlauDunkel}{ELF64}@
    Data:                              @\textcolor{TUMBlauDunkel}{2's complement, little endian}@
    Version:                           1 (current)
    OS/ABI:                            UNIX - @\textcolor{TUMBlauDunkel}{System V}@
    ABI Version:                       0
    Type:                              @\textcolor{TUMBlauDunkel}{EXEC}@ (Executable file)
    Machine:                           @\textcolor{TUMBlauDunkel}{RISC-V}@
    Version:                           0x1
    Entry point address:               @\textcolor{TUMBlauDunkel}{0x100b0}@
    Start of program headers:          64 (bytes into file)
    Start of section headers:          688 (bytes into file)
    Flags:                             0x5, RVC, double-float ABI
    Size of this header:               64 (bytes)
    Size of program headers:           56 (bytes)
    Number of program headers:         2
    Size of section headers:           64 (bytes)
    Number of section headers:         6
    Section header string table index: 5
        \end{lstlisting}
    \end{columns}
\end{frame}
\clearpage

%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Lifter General Folie %%
%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}
    \frametitle{Lifter}{RISC-V Instruktionen in IR Code umwandeln}
    \begin{enumerate}
        \setlength\itemsep{0.6em}
        \item Instruktionen sequenziell lesen:
              \pause{}
              \vspace{0.5em}
              \begin{enumerate}
                  \setlength\itemsep{0.6em}
                  \item Instruktionen in IR parsen
                        \pause{}
                  \item Wiederhole bis eine \textbf{Kontrollfluss ändernde Instruktion} auftritt
                        \pause{}
                  \item Beende Basic Block $\rightarrow$ starte neuen Basic Blöck für jede Kontrollflussänderung
                        \pause{}
                  \item Starte für jeden \textbf{neuen} Basic Block wieder bei 1
              \end{enumerate}
              \pause{}
        \item Sollte Schritt 1 nicht alle vorhandenen Instruktionen in Basic Blöcke gepackt haben:\\ Beginne ab erster \textbf{unbetrachteter} Adresse / Instruktion erneut mit Schritt 1
    \end{enumerate}
\end{frame}
\clearpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Lifter Backtracking und Splitting %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}
    \frametitle{Lifter}{Lifter Splitting und Backtracking}
    \vspace{2em}
    \pause{}
    \begin{columns}[c]
        \column{0.4 \textwidth}
        \textbf{Aufteilen eines Basic Blocks}
        \note[item]{Sprung zurück in bereits geparsten Codebereich}
        \note[item]{Split an Einsprungaddresse und Verbindung mit direktem Sprung}
        \begin{itemize}
            \item Situation: Sprung \textbf{in} einen Basic Block
            \item Aufteilung an Sprungadresse in zwei Basic Blöcke
            \item Verbindung mit einem direkten Sprung
        \end{itemize}
        \pause{}
        \column{0.4 \textwidth}
        \textbf{Backtracking einer indirekten Sprungadresse}
        \note[item]{Indirekte Sprünge, also Sprünge mit Register als Eingabeparameter}
        \note[item]{Rekursives Backtracking um Wert des Registers zu ermitteln}
        \note[item]{Mehrere Werte möglich -> im Moment wird erster gewählt (mögliche Fehlerquelle)}
        \begin{itemize}
            \item rekursive Rückverfolgung aller Argumente
            \item für "`statics"' werden alle möglichen Vorgänger betrachtet
            \item Aussortierung von Vorgängern
        \end{itemize}
    \end{columns}
\end{frame}
\clearpage

\note[itemize]{
    \item {Ein Basic Block muss aufgeteilt werden, wenn eine Kontrollflussoperation an eine Adresse springt, welche bereits geliftet ist und sich in diesem Basic Block befindet}
    \item {Warum muss ein Basic Block geteilt werden? -> damit nach Definition der IR immer an den Beginn eines Basic Blocks gesprungen werden kann}
    \item {bei Schleifen nötig -> siehe IR Beispiel vorher}
    \item {Unbedingter Sprung als Verbindung (nach )}
    \item {Variablen anhand Zuweisungsadresse (Adresse der Instruktion, welche sie erzeugt hat) auf die beiden Basic Blöcke aufgeteilt}
    \item {Sorgt für Probleme, weil Datenstruktur verändert wird, v.a. richtige Aufteilen der Variablen, korrekter Sprung, korrekter Transfer der Cfops}
    \item {Die Kontrollflussoperationen werden in den zweiten Basic Block (mit der höheren Adresse) geschoben, weil diese das Ende des Basic Blocks sind und sich damit garantiert im zweiten Befinden}
}

%%%%%%%%%%%%%%%%%%%%%
%% Generator Folie %%
%%%%%%%%%%%%%%%%%%%%%

\begin{frame}
    \frametitle{Generator}{Übersetztung der IR zu x86\_64}
    \pause{}
    \begin{itemize}
        \item Sehr einfache, aber korrekte übersetztung
              \pause{}
        \item RISC-V Stack wird simuliert % es wird nicht der x86-64 Stack verwendet
              \pause{}
        \item Indirekte Sprünge werden per Lookup zur Laufzeit aufgelöst
              \pause{}
        \item RISC-V System-V ABI (Startup, Syscall) zur Laufzeit emuliert
              \pause{}
        \item Original ELF Programm als binäres Speicherbild an exakter Adresse eingebunden
              \pause{}
        \item Erste Optimierung: Eliminerung von Redundanzen bei den Statics
    \end{itemize}
\end{frame}
\clearpage

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% Technische Demonstration %%
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

\begin{frame}[fragile]
    \frametitle{Technische Demonstration}{Live Demonstration des aktuellen Standes}

    % Dauer: ~3m
    \note[item]{Kompilieren zu RISCV-64 mit einer unmodifizierten musl libc (standardbibliothek)}
    \note[item]{Unser Program übersetzt zu x86 assembly + binary image}
    \note[item]{Assemblieren mittels GNU tools}
    \note[item]{Linken von binary image, übersetztem assembly und hilfsbibliothek}
    \note[item]{Ausführen}
    \note[item]{Ausführen, ungefährere Vergleich (native, qemu, translated) => Wo sind wir mit optimierungen, fast faktor 10 langsamer als QEMU}

    \begin{lstlisting}[language=bash, basicstyle=\footnotesize\ttfamily, extendedchars=true,escapeinside={@@}]
        ./big_tests/sysroot/bin/riscv64-linux-gnu-gcc \
            -static \
            examples/helloworld3.c \
            -o examples/helloworld3

        ./build/src/translate \
            @-@-debug=true \
            @-@-output-binary=examples/helloworld3.bin \
            @-@-output=examples/helloworld3_translated.s \
            examples/helloworld3

        gcc \
            -c examples/helloworld3_translated.s \
            -o examples/helloworld3_translated.o

        ld \
            -T src/generator/x86_64/helper/link.ld \
            examples/helloworld3_translated.o \
            build/src/generator/x86_64/helper/libhelper.a \
            -o examples/helloworld3_translated

        ./examples/helloworld3_translated
    \end{lstlisting}
\end{frame}
\clearpage

%%%%%%%%%%%%%%%%%%%%%
%% Erreichte Ziele %%
%%%%%%%%%%%%%%%%%%%%%

\begin{frame}
    \frametitle{Erreichte Ziele}{Erreichte Hauptziele und Ausblick}

    % Dauer: mind. 1 Minute, ansonsten flexible
    \note[item]{Freistehend => ohne standard bibliothek, z\.B\. handgeschriebenes assembly oder einfache C programme}
    \note[item]{Atomics werden nur also nicht atomics übersetzt so weit nötig}
    \note[item]{Demonstriert im Beispiel}
    \note[item]{2 Bugs in musl libc, malloc, fehlender BasicBlock in printf\_core wegen switch statement ohne control fluss änderung am ende von cases}
    \note[item]{Und noch vereinzelt weiter instructionen je nach bedarf}
    \note[item]{ijump eigentlich bei erweiterte Ziele, aber extrem wichtig da für return verwendet}

    \pause{}

    \begin{itemize}
        \item Korrektes Übersetzten einfacher freistehender Programme
            \pause{}
        \item Übersetzten von unmodifizierter musl libc
            \pause{}
        \item Unterstützung von RV64I, RV64C, \ldots{}
            \pause{}
        \item Auflösung indirekter Sprünge zur Laufzeit
            \pause{}
    \end{itemize}
\end{frame}

%%%%%%%%%%%%%%%%%%%
%% Noch Fragen ? %%
%%%%%%%%%%%%%%%%%%%

\begin{frame}
    \frametitle{Noch Fragen?}{}
\end{frame}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
\end{document} % !!! NICHT ENTFERNEN !!!
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
