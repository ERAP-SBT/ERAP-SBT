% Diese Zeile bitte -nicht- aendern.
\documentclass[course=eragp]{aspdoc}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% TODO: Ersetzen Sie in den folgenden Zeilen die entsprechenden -Texte- % mit den richtigen Werten.
\newcommand{\theGroup}{IhreGruppennummer} % Beispiel: 42
\newcommand{\theNumber}{IhreProjektnummer} % Beispiel: A123
% Authors, sorted by last name
\author{Lukas DÃ¶llerer \and Jonathan Hettwer \and Johannes Maier \and Tobias Schwarz \and Felix Solcher}
\date{Summer semester 2021}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Diese Zeile bitte -nicht- aendern. \title{Gruppe \theGroup{} -- Abgabe zu Aufgabe \theNumber}
\title{Static binary translation from RISC-V to x86\_64}

\begin{document}
\maketitle

\tableofcontents

\pagebreak

\section{Motivation and problem statement}

% Bullet points:
% - why to translate binaries?
%   - to use a program on another platform (e.g. source code lost / not available)
%   - (academic purposes :-))
% - How to translate binaries?
%   - DBT (dynamic binary translation): translate sequence of instructions and execute them
%   - SBT (static binary translation): translate binary to target ISA, then execute it (pro: higher
%     execution time)
% - comparable to difference between interpreted and compiled programs
% - our problem: SBT from RISC-V to x86-64
% - more academic problem, because most programs are available on x86-64 

In order to execute machine code, you need a processor which runs this machine code. But there are
many different processor families and instruction set architectures (ISA) for which programs are
developed. If you want to run a program which is written for an ISA where you don't have access to a
system running this ISA, e.g. RISC-V. Then you can translate it and execute it on another system,
e.g.\ x86\_64. There are three main approaches:

\par

Firstly you can use an emulator which ``[\ldots] interprets program instructions at
runtime.''\cite{binary_translation} The development is quite easy, but it is a rather slow method.

\par

Secondly, you can use dynamic binary translation (DBT) which works like an emulator but uses caching
to store already translated instruction sequences for future use. This increases the execution speed
compared to an emulator because often used instructions don't need to be translated
twice.\cite{binary_translation}

\par

And thirdly, you can translate the full binary to an ISA which the target system is able to execute.
That way you can separate translation and execution, which means you only have to translate the
binary once for running it as often you need. This increases execution speed. This approach is
called static binary translation (SBT).\cite{binary_translation}

\par

%The difference between SBT and DBT is comparable to the difference between compiled and interpreted
%programs. But whilst compilers and interpreters are working on high level programming languages,
%e.g. C, C++ or Python, SBT and DBT are used to translate machine language files.

\par

Our task is to
develop a static binary translator which translates RISC-V binaries to x86\_64 machine code. This
field of binary translation is a rather academic issue because currently, the x86\_64 is still a
more widely used ISA than RISC-V.\cite{riscv_rises} This means most programs are already available for the x86\_64
processor architecture.

\section{Background}
\subsection{Short overview of RISC-V}

According to the RISC-V specification~\cite{rvspec}, RISC-V is an open and freely accessible ISA
which consists of ``[\ldots] a small base integer ISA [\ldots]'' and ``[\ldots] optional standard
extensions to support general purpose software development''\cite[p.~1]{rvspec}. There is also
the option to implement custom extensions. It is available in
``[b]oth 32-bit and 64-bit address space variants for applications, operating system kernels, and
hardware implementations.''\cite[p.~1]{rvspec} As the name suggests, the RISC-V ISA describes a
\emph{Reduced Instruction Set Computer}. This kind of microprocessor is characterized by a larger
number of registers, its load/store architecture, fixed-length instruction words and a generally
limited amount of instructions and instruction formats.\cite{RISCvCISC}

\par

Currently there are standard extensions for multiplication and division (M), for atomic instructions (A),
for floating point arithmetic (F,D,Q), for compressed instructions to reduce the code size (C) and
for control and status registers (Ziscr). More standard extensions are planned.\cite{rvspec}

\subsection{Differences between RISC-V and x86\_64}
In contrast to RISC-V, the x86\_64 ISA describes a CISC, a \emph{Complex Instruction Set Computer}.
Its processors have a limited number of registers, richer instruction sets and variable length
instructions. Because of the complex instruction functions and formats, logic is often implemented
in mix between microcode and hard coded logic, executing instructions over a number of CPU clock
cycles.\cite{RISCvCISC}

\par

The x86\_64 ISA defines instructions which access memory and perform arithmetic or logical
operations at the same time. This is not possible with the load/store RISC-V architecture. Because
of their variable instruction lengths, x86\_64 instructions can contain immediate values which are
up to 64-bit wide.\cite[Vol.~2B~p.~4-35]{intel2017man} RISC-V base instructions are currently always
32-bit wide (16-bit for compressed instructions)\cite[p.~8]{rvspec} which makes loading big
immediates difficult. These are either combined by two or more separate immediate loading operations
or loaded relative to the current instruction pointer.\cite[p.~19]{rvspec} The latter is also often
used for performing jumps.\cite [p.~20]{rvspec}

\par

For the translation this differences are necessary knowledge to be able to generate efficient and optimized code.
For example some instructions need to be assembled or can be merged to a single instruction in x86\_64.

\subsection{Inspiration}

\section{Approach}

We divided the translation process in three main parts: lifting, optimization and generation. We
made this division to structure the program and to simplify the usage of optimizations. The parts
are independent to at least theoretically save the opportunity to support other ISA as source
or target. But this isn't the focus of this project.

\par

The lifter reads the instructions from the binary file using frvdec\cite{frvdec} to disassemble the
RISC-V binary and creates operations and variables in the intermediate representation (IR). This is
a data structure we defined for the usage in this project. It contains the logic of the input binary
in a form we can optimize. This optimizations are performed by optimizer and are used to
reduce the execution time of the output binary. This binary is created by the generator translating
the IR variables and operations to x86\_64 assembly. To produce an executable binary we use the GNU
assembler (GAS)\cite{gnu_binutils} and link our helper library to it using the GNU linker
(LD)\cite{gnu_binutils}. For further explanation see the following chapters.

\section{Intermediate representation}

\section{Lifter}
\subsection{General method}
\subsection{Floating point support}
\subsection{Backtracking}
Although indirect jump addresses can be evaluated at runtime, we can only jump to the beginning of
detected basic blocks. This is because we can optimize \nameref{dead_code_elimination} and fold
instructions \nameref{constant_folding} inside basic blocks without altering the control flow or
logic of the program. Having a completely runnable program thus means detecting every basic block
with their corresponding entrypoints. Although determining all possible indirect jump targets
statically is not possible or not feasible (e.g.\ jump targets could be influenced by user input),
backtracking register contents during lifting gives us a good approximation of the target set.

\subsection{Call and return optimization}
\subsection{Jump table detection}

\section{Optimizations}
\subsection{Constant Folding}\label{constant_folding}

\subsection{Dead Code Elimination}\label{dead_code_elimination}

\clearpage

\section{Generator}
\subsection{Interpreter}
\subsection{Naive implementation}
\subsection{Register allocation}
\subsection{Helper library}\label{helper}

\section{Performance}
\subsection{Our solution}
\subsection{Optimierungen (Analyse)}
\subsection{QEMU}
\subsection{Dynamic translator last year}
\subsection{Native x86\_64}

\section{Summary}

% TODO: Fuegen Sie Ihre Quellen der Datei Ausarbeitung.bib hinzu Referenzieren Sie diese dann mit
% \cite{}. Beispiel: CR2 ist ein Register der x86-Architektur~\cite{intel2017man}.
\bibliographystyle{plain}
\bibliography{Ausarbeitung}{}

\end{document}
