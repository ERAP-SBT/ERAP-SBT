% Diese Zeile bitte -nicht- aendern.
\documentclass[course=eragp]{aspdoc}

\input{commands.tex}

%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%
%% TODO: Ersetzen Sie in den folgenden Zeilen die entsprechenden -Texte- % mit den richtigen Werten.
\newcommand{\theGroup}{IhreGruppennummer} % Beispiel: 42
\newcommand{\theNumber}{IhreProjektnummer} % Beispiel: A123
% Authors, sorted by last name
\author{Lukas DÃ¶llerer \and Jonathan Hettwer \and Johannes Maier \and Tobias Schwarz \and Felix Solcher}
\date{Summer semester 2021}
%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%%

% Diese Zeile bitte -nicht- aendern. \title{Gruppe \theGroup{} -- Abgabe zu Aufgabe \theNumber}
\title{Static binary translation from RISC-V to x86\_64}

\begin{document}
\maketitle

\tableofcontents

\pagebreak

\section{Motivation and problem statement}

% Bullet points:
% - why to translate binaries?
%   - to use a program on another platform (e.g. source code lost / not available)
%   - (academic purposes :-))
% - How to translate binaries?
%   - DBT (dynamic binary translation): translate sequence of instructions and execute them
%   - SBT (static binary translation): translate binary to target ISA, then execute it (pro: higher
%     execution time)
% - comparable to difference between interpreted and compiled programs
% - our problem: SBT from RISC-V to x86-64
% - more academic problem, because most programs are available on x86-64

In order to execute machine code, you need a processor which runs this machine code. But there are
many different processor families and instruction set architectures (ISA) for which programs are
developed. If you want to run a program which is written for an ISA where you don't have access to a
system running this ISA, e.g. RISC-V. Then you can translate it and execute it on another system,
e.g.\ x86\_64. There are three main approaches:

\par

Firstly you can use an emulator which ``[\ldots] interprets program instructions at
runtime.''\cite{binary_translation} The development is quite easy, but it is a rather slow method.

\par

Secondly, you can use dynamic binary translation (DBT) which works like an emulator but uses caching
to store already translated instruction sequences for future use. This increases the execution speed
compared to an emulator because often used instructions don't need to be translated
twice.\cite{binary_translation}

\par

And thirdly, you can translate the full binary to an ISA which the target system is able to execute.
That way you can separate translation and execution, which means you only have to translate the
binary once for running it as often you need. This increases execution speed. This approach is
called static binary translation (SBT).\cite{binary_translation}

\par

%The difference between SBT and DBT is comparable to the difference between compiled and interpreted
%programs. But whilst compilers and interpreters are working on high level programming languages,
%e.g. C, C++ or Python, SBT and DBT are used to translate machine language files.

\par

Our task is to
develop a static binary translator which translates RISC-V binaries to x86\_64 machine code. This
field of binary translation is a rather academic issue because currently, x86\_64 is still a
more widely used ISA than RISC-V.\cite{riscv_rises} This means most programs are already available for the x86\_64
processor architecture.

\section{Background}
\subsection{Short overview of RISC-V}

According to the RISC-V specification~\cite{rvspec}, RISC-V is an open and freely accessible ISA
which consists of ``[\ldots] a small base integer ISA [\ldots]'' and ``[\ldots] optional standard
extensions to support general purpose software development''\cite[p.~1]{rvspec}. There is also
the option to implement custom extensions. It is available in
``[b]oth 32-bit and 64-bit address space variants for applications, operating system kernels, and
hardware implementations.''\cite[p.~1]{rvspec} As the name suggests, the RISC-V ISA describes a
\emph{Reduced Instruction Set Computer}. This kind of microprocessor is characterized by a larger
number of registers, its load/store architecture, fixed-length instruction words and a generally
limited amount of instructions and instruction formats.\cite{RISCvCISC}

\par

Currently there are standard extensions for multiplication and division (M), for atomic instructions (A),
for floating point arithmetic (F,D,Q), for compressed instructions to reduce the code size (C) and
for control and status registers (Ziscr). More standard extensions are planned.\cite{rvspec}

\subsection{Differences between RISC-V and x86\_64}
In contrast to RISC-V, the x86\_64 ISA describes a CISC, a \emph{Complex Instruction Set Computer}.
Its processors have a limited number of registers, richer instruction sets and variable length
instructions. Because of the complex instruction functions and formats, logic is often implemented
in mix between microcode and hard coded logic, executing instructions over a number of CPU clock
cycles.\cite{RISCvCISC}

\par

The x86\_64 ISA defines instructions which access memory and perform arithmetic or logical
operations at the same time. This is not possible with the load/store RISC-V architecture. Because
of their variable instruction lengths, x86\_64 instructions can contain immediate values which are
up to 64-bit wide.\cite[Vol.~2B~p.~4-35]{intel2017man} RISC-V base instructions are currently always
32-bit wide (16-bit for compressed instructions)\cite[p.~8]{rvspec} which makes loading big
immediates difficult. These are either combined by two or more separate immediate loading operations
or loaded relative to the current instruction pointer.\cite[p.~19]{rvspec} The latter is also often
used for performing jumps.\cite [p.~20]{rvspec}

\par

For the translation this differences are necessary knowledge to be able to generate efficient and optimized code.
For example some instructions need to be assembled or can be merged to a single instruction in x86\_64.

\subsection{Inspiration}

\section{Approach}

We divided the translation process in three main parts: lifting, optimization and generation. We
made this division to structure the program and to simplify the implementation of optimizations.
%% --- im not 100% sure that this is right, please change it if its wrong --- %%
The parts are independent to at least theoretically save the opportunity to support other ISA as
source or target. But this isn't the focus of this project.
%% -------------------------------------- END ------------------------------- %%

\par

The lifter reads the instructions from the binary file using frvdec\cite{frvdec} to disassemble the
RISC-V binary into basic blocks and creates operations and variables in the intermediate representation (IR).
It contains the logic of the input binary in an architecture-neutral form which generic optimization passes can
be applied on to reduce the number of operations to be performed so that the generator can more easily create native instructions from it.
The translated binary is created by the generator compiling the IR variables and operations to x86\_64 assembly. To produce an executable binary we use the GNU
assembler (GAS)\cite{gnu_binutils} and link our helper library to it using the GNU linker
(LD)\cite{gnu_binutils}. For further explanation see the following chapters. Figure
\ref{program_overview} depicts the main structure as a scheme.

\begin{figure}
    \centering
    \ProgramSchemeVersionOne{0.43}{13}
    \caption{
        A schematic representation of the translator's internal structure.
    }
    \label{program_overview}
\end{figure}

\par

Our implementation only accepts 64bit ELF binaries which are statically linked and in little endian
format. Another requirement is that the binary is created for unix or uses the System V Application
Binary Interface (ABI) because this defines the system call ids and the calling convention.
Obviously the ELF file also has to be a RISC-V binary. This prerequisites are checked before
translating the file in order to print meaningful debug messages.


\section{Intermediate representation}

\section{Lifter}
\subsection{General method}
\subsection{Floating point support}
\subsection{Backtracking}\label{backtracking}
Although indirect jump addresses can be evaluated at runtime, we can only jump to the beginning of
detected basic blocks. This is the case, because we can optimize (\ref{dead_code_elimination}) and fold
instructions (\ref{constant_folding}) inside basic blocks without altering the control flow or
logic of the program and as such there might often not be a one-to-one correspondence of RISC-V to x86\_64-Instructions.
Having a completely runnable program thus means detecting every basic block
with their corresponding entry points (including their exit points). Although determining all possible 
indirect jump targets statically is not possible (e.g. virtual function calls)
% or not feasible (e.g. jump targets could be influenced by user input)
, backtracking register contents during lifting can provide us with 
an approximation of the target set.

\par

To statically determine indirect jump target addresses, we need to evaluate possible contents of
the jump's input register operand. Each variable stores its origin, being either the result of an
operation, an immediate value or from a static. This enables us to backtrack the value of
any variable in the call tree until we reached a variable which can't be backtracked or until we evaluated
all possible values.

\par

Registers keep their values between jumps and calls. We model this behavior using static mappers
which bind variables to their registers in between basic blocks. For backtracking, this means a
variable which is bound to a static mapper can have any value that the variable mapped to the same
static mapper in its basic block's predecessors has. This opens up a room of variables which
influence the jump target, growing with the amount of predecessors and operation inputs.

\par

Figure~\ref{backtracking_graph} shows an example for such a call tree. The basic block \emph{bb24} ends
with an indirect jump, jumping to the address stored in \emph{v37}. \emph{ADD} and \emph{SHL} are operations.

\begin{figure}
    \centering
    \begin{tikzpicture}
        \begin{pgfonlayer}{nodelayer}
            \node [style=BB] (0) at (-3.75, 0) {bb24};
            \node [style=VAR] (1) at (-2.25, 0) {v37};
            \node [style=OP] (2) at (-0.75, 0) {ADD};
            \node [style=VAR] (3) at (0.5, 1.5) {v36};
            \node [style=VAR] (4) at (0.5, -1.5) {v34};
            \node [style=OP] (5) at (2, -1.5) {SHL};
            \node [style=VAR] (6) at (3.5, 0.25) {v15};
            \node [style=VAR] (7) at (3.5, -1.5) {v22};
            \node [style=STATIC] (8) at (5, 0.25) {x14};
            \node [style=STATIC] (9) at (5, -1.5) {x21};
            \node [style=BB] (10) at (6.5, 1) {bb42};
            \node [style=BB] (11) at (6.5, -1) {bb23};
            \node [style=BB] (12) at (6.5, 2) {bb8};
            \node [style=BB] (13) at (6.5, 0) {bb17};
            \node [style=BB] (14) at (6.5, -2.25) {bb127};
            \node [style=VALUE] (15) at (2, 1.5) {-2};
            \node [style=VAR] (16) at (7.75, 2) {};
            \node [style=VAR] (18) at (7.75, 0) {};
            \node [style=VAR] (19) at (7.75, -1) {};
            \node [style=BB] (23) at (9.75, 1) {};
            \node [style=BB] (24) at (9.75, -2.25) {};
            \node [style=OP] (25) at (8.75, 0) {};
            \node [style=OP] (26) at (8.75, -1) {};
            \node [style=OP] (28) at (8.75, 2) {};
            \node [style=VAR] (29) at (7.75, 1) {};
            \node [style=VAR] (31) at (7.75, -2.25) {};
            \node [style=STATIC] (32) at (8.75, 1) {};
            \node [style=STATIC] (33) at (8.75, -2.25) {};
            \node [style=none] (34) at (9.75, 2) {};
            \node [style=none] (35) at (9.75, 1.5) {};
            \node [style=none] (36) at (9.75, 0.25) {};
            \node [style=none] (37) at (9.75, -0.25) {};
            \node [style=none] (38) at (9.75, -0.75) {};
            \node [style=none] (39) at (9.75, -1.25) {};
            \node [style=none] (40) at (9.75, 2.5) {};
        \end{pgfonlayer}
        \begin{pgfonlayer}{edgelayer}
            \draw [style=LINK] (0) to (1);
            \draw [style=LINK] (1) to (2);
            \draw [style=LINK] (2) to (3);
            \draw [style=LINK] (2) to (4);
            \draw [style=LINK] (3) to (15.center);
            \draw [style=LINK] (4) to (5);
            \draw [style=LINK] (5) to (7);
            \draw [style=LINK] (5) to (6);
            \draw [style=LINK] (6) to (8);
            \draw [style=LINK] (7) to (9);
            \draw [style=LINK] (9) to (14);
            \draw [style=LINK] (9) to (11);
            \draw [style=LINK] (8) to (13);
            \draw [style=LINK] (8) to (10);
            \draw [style=LINK] (8) to (12);
            \draw [style=LINK] (12) to (16);
            \draw [style=LINK] (13) to (18);
            \draw [style=LINK] (11) to (19);
            \draw [style=LINK] (16) to (28);
            \draw [style=LINK] (10) to (29);
            \draw [style=LINK] (29) to (32);
            \draw [style=LINK] (18) to (25);
            \draw [style=LINK] (14) to (31);
            \draw [style=LINK] (31) to (33);
            \draw [style=LINK] (33) to (24);
            \draw [style=LINK] (19) to (26);
            \draw [style=LINK] (32) to (23);
            \draw [style=DASHED] (28) to (34.center);
            \draw [style=DASHED] (28) to (35.center);
            \draw [style=DASHED] (25) to (36.center);
            \draw [style=DASHED] (25) to (37.center);
            \draw [style=DASHED] (26) to (38.center);
            \draw [style=DASHED] (26) to (39.center);
            \draw [style=DASHED] (28) to (40.center);
        \end{pgfonlayer}
    \end{tikzpicture}
    \caption{
        Exemplary variable backtracking graph.\\
        \textbf{bb}: BasicBlock; \textbf{v}: Variable; \textbf{x}: StaticMapper;
    }\label{backtracking_graph}
\end{figure}

% TODO: divide this into two parts, one lifter one generator? since there are two distinct parts to it
\subsection{Call and return optimization}
The RISC-V architecture doesn't include special operations for handling subroutines. A function call 
is assembled as a jump which places the address of the next instruction into a \emph{link-}register
\emph{x1} or \emph{x5} (for the standard calling convention).\cite[p.~20]{rvspec} Returning from a
subroutine is done by jumping to the address which is contained in either of those registers. This
behavior is further optimized with the compressed instructions \emph{C.JAL} and
\emph{C.JALR}. These operations implicitly store the address of the next instruction
to the link register \emph{x1}.[p.~105]\cite{rvspec}

\par

Subroutine calls which jump to an address in a register are so called \emph{icalls}. They act
similar to indirect jumps and are backtracked in the same way. However, target detection success for indirect calls
doesn't affect stack alignment. Even if we can't determine an indirect call target, we still perform
an x86\_64 \emph{call} which pushes the instruction pointer onto the stack and jumps to the address
in the supplied register. This works as long as we were able to identify the jump address as a basic
block's entry point with the procedure described in the section\ \ref{backtracking}.

\subsection{Jump table detection}

As described in\ \cite{jump_table_paper}, n-conditional case statements, like the C programming
language's switch-case statement, are often implemented by compilers using jump
tables. A jump table is a pattern which enables efficient\footnote{Because the integer condition is
used as the jump address selector, this is only efficient for switch-statements with small entry
ranges (e.g.\ enum switching).} branching based
on a stored set of addresses which are possible jump targets. This means we need to detect jump tables to find
all possible basic block entry points. 

\par

The jump table pattern always involves consists of a particular set of RISC-V instructions.
At the beginning, a bounds check is executed. A branching instruction is used to either jump to the
default branch or the code after the switch if the switch condition (an integer) is above the
highest case value. 

\par 

If this is not the case, the switch condition is multiplied by a factor of 4. 
Using a combination of a \emph{lui} and an \emph{addi} instruction, it is possible to load a full
32-bit constant\ \cite[p.~19]{rvspec} representing the start address of the jump table.
This address is added to the integer condition. The resulting value is the memory address
at which the desired jump address is stored. A 32-bit load is executed to load the value into a
register. An indirect jump to this register's content is the final instruction, executing the case
label jump. 

\par 

For the jump table detection, we just backtrack the previously described pattern for every
encountered indirect jump. If the jump turns out to be part of a jump table configuration, we can
extract the jump target addresses and use them as entry points for new basic blocks. This also works
for switch-statements which are compiled into a combination of jump tables and branch-based search
trees.

\section{Optimizations}
\subsection{Dead Code Elimination}\label{dead_code_elimination}

There are cases in compiled programs, where a value is written to a register, but never read from again.
When lifted, these register writes are found in the IR as unused variables, which can be removed.
This is accomplished by visiting the variables in reverse order, and dropping them when their reference-count is zero.
This also takes care of ``cascading'' deletes, as the reference-count for inputs of an operation is decreased once the
operation is deleted.

Another purpose of the Dead Code Elimination pass is to remove unused inputs from BasicBlocks. For this, the
reference-count does not suffice, since there might be circular control flow (like in loops). Instead, the Dead Code
Elimination pass marks each variable associated with side effects, i.e. variables used in \texttt{store}s,
\texttt{syscall}s and jumps to unknown targets like \texttt{ijump}s. This marking is then propagated through the IR,
until no more variables are reachable. Then, all unmarked variables and inputs can be deleted.

\subsection{Constant Folding and Constant Propagation}\label{constant_folding}

Constant Folding and Constant Propagation are closely related optimizations, where operations with known input values
(i.e. immediate values) are computed, and immediate variables are propagated throughout BasicBlocks.
In our implementation, Constant Folding, Constant Propagation and operation simplifications are grouped into the same
pass.  As such, we'll further refer to these collectively as Constant Folding.

This optimization pass is done by visiting each operation in a BasicBlock in order, making the pass run in linear time.
Depending on the inputs of an operation, one of several actions can be performed.

In the simplest case, all inputs are immediates. The result of the operation can be computed, and the variable is
replaced with the resulting immediate value. One exception to this are binary-relative immediates---immediates which are
offset at runtime by the base address of the binary. Hence, only addition and subtraction with one binary-relative and
one non-binary-relative immediate operand are evaluable, and evaluating subtraction is only sensible if the
binary-relative immediate is the first operand.

The next case is one immediate input and one non-immediate (static or operation) input. Generally, this case allows for
simplification of identity operations, like addition with zero. If the non-immediate operand is an operation with an
immediate operand itself, the two immediates can be evaluated under the rules of associativity and commutativity
(Exceptions for binary-relative immediates still apply).

A simple example for the simplification is the \texttt{NOP}-pseudoinstruction in RISC-V, which is usually encoded as
\texttt{ADDI x0, x0, 0}.\cite[p.~20]{rvspec} The addition with zero does not change the value, and all occurrences of
the result variable can be replaced with the input variable (In practice, this simple case can already be detected in
the lifting stage).

This optimization is greatly simplified by the use of Static Single Assignment form in the IR, since variables can't be
reassigned. This means that the value of a variable is known just by looking at the declaration of the variable.

\clearpage

\section{Generator}
The generator has two jobs. % TODO: jobs isnt the right word...
Firstly, it needs to assemble all basic blocks which means assembling all variables with their associated operations,
preparing the inputs for the next basic block and creating the control flow operations.
Secondly, it needs to provide for a runtime environment, namely the original binary in its memory-layouted
form, a stack for the translated binary to use as the x86\_64-Stack is reserved for the generator, a resolver for ijumps
along with an interpreter which acts as a fallback if an indirect jump to an address at which no basic block starts is encountered
and architecture-specific functions like a routine to create an initial stack for the translated binary as well as a routine to translate syscalls.
Most of these are bundled into a static library that is linked to the generated assembly called the Helper-Library.
\subsection{Naive implementation}
For assembly generation, the generator operates in two distinct modes which we refer to as the "naive" implementation and register allocation.
\par
The naive implementation is meant to serve as a simple codegen which is necessary to ease debugging and to better evaluate gains from
optimizations in the IR as it very closely recreates the IR operations.

\par

It generates assembly for each basic block independently.
For each one it creates a stack frame which holds space for every variable in the basic block, iterates all operations and
retrieves its sources - either from a static or from the stack frame -, applies the operation and then saves the results in the stack frame again.
At the end of a block it iterates all control flow operations, evaluates its condition if necessary, writes out the inputs for the next basic block
from the stack frame and either calls a helper routine or directly jumps to the next block.

% TODO: example
\subsection{Register allocation}
\subsection{Merging operations}
\subsection{Interpreter}
\subsection{Helper library}\label{helper}

\section{Performance}
\subsection{Our solution}
\subsection{Optimierungen (Analyse)}
\subsection{QEMU}
\subsection{Dynamic translator last year}
\subsection{Native x86\_64}

\section{Summary}

% TODO: Fuegen Sie Ihre Quellen der Datei Ausarbeitung.bib hinzu Referenzieren Sie diese dann mit
% \cite{}. Beispiel: CR2 ist ein Register der x86-Architektur~\cite{intel2017man}.
\bibliographystyle{plain}
\bibliography{Ausarbeitung}{}

\end{document}
